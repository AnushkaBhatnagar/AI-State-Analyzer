#!/usr/bin/env python3
"""
Enhanced server for AI State Analyzer with stage modification support
Provides API endpoints for saving stage modifications and serving snapshots
"""

from flask import Flask, request, jsonify, send_from_directory
from flask_cors import CORS
import json
import os
from pathlib import Path
from datetime import datetime
import webbrowser
import threading
import time

app = Flask(__name__)
CORS(app)  # Enable CORS for all routes

PORT = 8000
BASE_DIR = Path(__file__).parent

# Serve static files
@app.route('/')
def index():
    return send_from_directory(BASE_DIR, 'index_with_panel.html')

@app.route('/state_editor_panel.html')
def state_editor():
    return send_from_directory(BASE_DIR, 'state_editor_panel.html')

@app.route('/states_schema.json')
def states_schema():
    return send_from_directory(BASE_DIR, 'states_schema.json')

@app.route('/<path:path>')
def serve_static(path):
    return send_from_directory(BASE_DIR, path)

# API: Save stage modification to MD file
@app.route('/api/save-modification', methods=['POST'])
def save_modification():
    try:
        data = request.json
        stage = data['stage']
        function_name = data['functionName']
        code = data['code']
        changes = data.get('changes', [])
        timestamp = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
        
        # Create MD content
        md_content = f"""# Stage Modification Request

## Metadata
- **Stage:** {stage}
- **Function:** `{function_name}()`
- **Timestamp:** {timestamp}
- **Status:** Pending ‚è≥

---

## Changes Requested

"""
        
        # Add change descriptions
        if changes:
            for i, change in enumerate(changes, 1):
                md_content += f"{i}. {change}\n"
        else:
            md_content += "User modified the function code directly.\n"
        
        md_content += f"""

---

## Modified Function Code

```javascript
{code}
```

---

## Instructions for Cline

Please apply these changes to `index.html`:

1. Locate the `{function_name}()` function
2. Replace it with the modified version above
3. Ensure proper formatting and syntax
4. Save the file

**Function locations:**
- Stage 0: `startHell()` (lines ~400-430, first part)
- Stage 1: `startHell()` (lines ~430-440, transition logic)
- Stage 2: `startStage2()` (lines ~450-470)
- Stage 3: `startStage3()` (lines ~480-510)
- Stage 4: `startHell4()` (lines ~520-580)

---

## After Applying

Once you've applied these changes:
1. Confirm the changes were applied successfully
2. Update this file's status to "Applied ‚úÖ"
3. Add the timestamp of when changes were applied

---

**Generated by:** AI State Analyzer Stage Editor
**File:** stage_modifications.md
"""
        
        # Save to MD file
        md_file = BASE_DIR / 'stage_modifications.md'
        with open(md_file, 'w') as f:
            f.write(md_content)
        
        # Also append to history
        history_file = BASE_DIR / 'stage_modifications_history.md'
        history_entry = f"""
## {timestamp} - Stage {stage} ({function_name})

**Changes:**
"""
        if changes:
            for change in changes:
                history_entry += f"- {change}\n"
        else:
            history_entry += "- Direct code modification\n"
        
        history_entry += f"**Status:** Pending ‚è≥\n\n---\n"
        
        # Append to history (create if doesn't exist)
        if history_file.exists():
            with open(history_file, 'a') as f:
                f.write(history_entry)
        else:
            with open(history_file, 'w') as f:
                f.write("# Stage Modification History\n\n")
                f.write(history_entry)
        
        return jsonify({
            'success': True,
            'message': 'Modification saved to stage_modifications.md',
            'file': str(md_file),
            'instruction': 'Ask Cline: "Apply the stage modifications from stage_modifications.md"'
        })
    
    except Exception as e:
        return jsonify({
            'success': False,
            'error': str(e)
        }), 500

# API: Get available snapshots
@app.route('/api/snapshots', methods=['GET'])
def get_snapshots():
    try:
        snapshots_dir = BASE_DIR / 'playwright_recorder' / 'snapshots'
        
        if not snapshots_dir.exists():
            return jsonify({
                'success': True,
                'sessions': [],
                'message': 'No snapshots found. Record a session first.'
            })
        
        sessions = []
        for session_dir in snapshots_dir.iterdir():
            if session_dir.is_dir():
                stages = []
                for stage_file in sorted(session_dir.glob('stage_*.json')):
                    stage_num = int(stage_file.stem.split('_')[1])
                    stages.append(stage_num)
                
                if stages:
                    sessions.append({
                        'name': session_dir.name,
                        'stages': stages,
                        'path': str(session_dir)
                    })
        
        return jsonify({
            'success': True,
            'sessions': sessions
        })
    
    except Exception as e:
        return jsonify({
            'success': False,
            'error': str(e)
        }), 500

# API: Load a specific stage snapshot
@app.route('/api/load-stage/<session>/<int:stage>', methods=['GET'])
def load_stage(session, stage):
    try:
        snapshot_file = BASE_DIR / 'playwright_recorder' / 'snapshots' / session / f'stage_{stage}.json'
        
        if not snapshot_file.exists():
            return jsonify({
                'success': False,
                'error': f'Snapshot not found: {snapshot_file}'
            }), 404
        
        with open(snapshot_file, 'r') as f:
            snapshot = json.load(f)
        
        return jsonify({
            'success': True,
            'snapshot': snapshot
        })
    
    except Exception as e:
        return jsonify({
            'success': False,
            'error': str(e)
        }), 500

# API: Get function code from index.html
@app.route('/api/get-function/<function_name>', methods=['GET'])
def get_function(function_name):
    try:
        index_file = BASE_DIR / 'index.html'
        
        if not index_file.exists():
            return jsonify({
                'success': False,
                'error': 'index.html not found'
            }), 404
        
        with open(index_file, 'r') as f:
            content = f.read()
        
        # Special handling for floodOverlay (State 5)
        if function_name == 'floodOverlay':
            # Extract the flood overlay trigger code from startHell4
            import re
            pattern = r'if \(notificationCount >= 150\) \{[^}]*setTimeout\(function\(\) \{[^}]*document\.getElementById\(\'floodOverlay\'\)\.style\.display = \'flex\';[^}]*\}, \d+\);[^}]*\}'
            match = re.search(pattern, content, re.DOTALL)
            if match:
                code = f"// Flood Overlay Trigger (from startHell4)\n// This code shows the final overlay\n\n{match.group(0)}"
                return jsonify({
                    'success': True,
                    'code': code
                })
        
        # Extract function code using brace counting for proper nesting
        import re
        pattern = rf'function {function_name}\s*\([^)]*\)\s*\{{'
        match = re.search(pattern, content)
        
        if match:
            start_pos = match.start()
            brace_start = match.end() - 1  # Position of opening brace
            
            # Count braces to find matching closing brace
            brace_count = 1
            pos = brace_start + 1
            
            while pos < len(content) and brace_count > 0:
                if content[pos] == '{':
                    brace_count += 1
                elif content[pos] == '}':
                    brace_count -= 1
                pos += 1
            
            if brace_count == 0:
                function_code = content[start_pos:pos]
                return jsonify({
                    'success': True,
                    'code': function_code
                })
        
        return jsonify({
            'success': False,
            'error': f'Function {function_name} not found'
        }), 404
    
    except Exception as e:
        return jsonify({
            'success': False,
            'error': str(e)
        }), 500

def open_browser():
    """Open browser after server starts"""
    time.sleep(1.5)
    url = f"http://localhost:{PORT}/index_with_panel.html"
    print(f"\nüåê Opening: {url}\n")
    webbrowser.open(url)

def main():
    print("\n" + "="*70)
    print("AI STATE ANALYZER - ENHANCED SERVER")
    print("="*70)
    print(f"Server running at: http://localhost:{PORT}/")
    print(f"Serving directory: {BASE_DIR}")
    print()
    print("Available endpoints:")
    print(f"  ‚Ä¢ http://localhost:{PORT}/index_with_panel.html")
    print(f"  ‚Ä¢ http://localhost:{PORT}/api/save-modification")
    print(f"  ‚Ä¢ http://localhost:{PORT}/api/snapshots")
    print(f"  ‚Ä¢ http://localhost:{PORT}/api/load-stage/<session>/<stage>")
    print()
    print("="*70)
    print("Press Ctrl+C to stop the server")
    print("="*70 + "\n")
    
    # Open browser in background
    browser_thread = threading.Thread(target=open_browser, daemon=True)
    browser_thread.start()
    
    # Start Flask server
    app.run(host='0.0.0.0', port=PORT, debug=False)

if __name__ == '__main__':
    main()
